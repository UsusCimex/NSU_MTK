import calcDiff;

/*
Реализуйте функцию преобразования алгебраического выражения в рациональную функцию (отношение двух многочленов).
*/

export {
    ratPolynom : (numerator : Expr, denominator : Expr);

    sumRatPolynom(l : Maybe<ratPolynom>, r : Maybe<ratPolynom>)  -> Maybe<ratPolynom>;
    subRatPolynom(l : Maybe<ratPolynom>, r : Maybe<ratPolynom>)  -> Maybe<ratPolynom>;
    mulRatPolynom(l : Maybe<ratPolynom>, r : Maybe<ratPolynom>)  -> Maybe<ratPolynom>;
    divRatPolynom(l : Maybe<ratPolynom>, r : Maybe<ratPolynom>)  -> Maybe<ratPolynom>;
    ratPolynom2s(rat : Maybe<ratPolynom>)                        -> string;
    calculatePolynomRat(v : Expr, params : Tree<string, ratNum>) -> Maybe<ratPolynom>;
    simplificationRat(rat : Maybe<ratPolynom>)                   -> Maybe<ratPolynom>;
}

simplificationRat(rat : Maybe<ratPolynom>) -> Maybe<ratPolynom> {
    switch (rat) {
        Some(v) : {
            if (v.numerator.structname == "Int" && v.denominator.structname == "Int") {
                tInt  = cast(v.numerator : Expr -> Int);
                tInt2 = cast(v.denominator : Expr -> Int);
                switch(divRatNum(Some(ratNum(tInt.val, 1)), Some(ratNum(tInt2.val, 1)))) {
                    Some(v2) : Some(ratPolynom(Int(v2.numerator), Int(v2.denominator)));
                    None() : None();
                }
            } else {
                numerator = v.numerator;
                denominator = v.denominator;
                tr = makeTree();
                trNum = polynom2tree(numerator, tr);
                trDen = polynom2tree(denominator, tr);

                newTrees = treeCutting(trNum, trDen);
                
                newNumerator = tree2polynom(newTrees.first, Var("x"));
                newDenominator = tree2polynom(newTrees.second, Var("x"));

                Some(ratPolynom(newNumerator, newDenominator));
            }
        }
        None() : None();
    }
}

treeCutting(tree1 : Tree<int, int>, tree2 : Tree<int, int>) -> Pair<Tree<int, int>, Tree<int, int>> {
    t1 = switch(popmin(tree1)) {
            PopResult(k, v, rest) : Pair(k, v);
            EmptyPopResult()      : Pair(0, 1);
        }
    t2 = switch(popmin(tree2)) {
            PopResult(k, v, rest) : Pair(k, v);
            EmptyPopResult()      : Pair(0, 1);
        }

    nod = gcdA(concat(getTreeValues(tree1), getTreeValues(tree2)));

    mn = min(t1.first, t2.first);
    res1 = foldTree(tree1, makeTree(), \k,v,res -> setTree(res, k - mn, v / nod));
    res2 = foldTree(tree2, makeTree(), \k,v,res -> setTree(res, k - mn, v / nod));
    Pair(res1, res2);
}

polynom2tree(ex : Expr, tree : Tree<int, int>) -> Tree<int, int> {
    switch (ex) {
		Mul(a, b) : {
            p = getMonomialOrder(ex);
            switch (lookupTree(tree, p.first)) {
                Some(v) : setTree(tree, p.first, p.second + v);
                None() : setTree(tree, p.first, p.second);
            }
        }
		Sum(a, b) : {
            tr = polynom2tree(a, tree);
            polynom2tree(b, tr);
        }
        Div(a, b) : tree;
        Sub(a, b) : {
            tr = polynom2tree(b, tree);
            mTr = foldTree(tr, makeTree(), \k,v,res -> setTree(res, k, -v));
            polynom2tree(a, mTr);
        }
        Neg(a)    : polynom2tree(a, tree);
        Int(a)    : switch(lookupTree(tree, 0)) {
                        Some(v) : setTree(tree, 0, v + a);
                        None() : setTree(tree, 0, a);
                    }
        Var(a)    : switch(lookupTree(tree, 1)) {
                        Some(v) : setTree(tree, 1, v + 1);
                        None() : setTree(tree, 1, 1);
                    }
	}
}

tree2polynom(tree : Tree<int, int>, var : Var) -> Expr {
    switch (popmin(tree)) {
        PopResult(k, v, rest) : simplification( Sum(tree2polynom(rest, var), getMonomial(k, v, var)) );
        EmptyPopResult()      : Int(0);
    }
}

getMonomial(order : int, value : int, var : Var) -> Expr {
    if (order <= 0) Int(value)
    else simplification( Mul(getMonomial(order - 1, value, var), var) ); 
}

// Return pair(oder, value)
getMonomialOrder(ex : Expr) -> Pair<int, int> {
    switch (ex) {
        Int(a)    : Pair(0, a);
        Neg(a)    : getMonomialOrder(a);
        Sum(a, b) : Pair(0,0);
        Sub(a, b) : Pair(0,0);
        Div(a, b) : Pair(0,0);
        Mul(a, b) : {
            m1 = getMonomialOrder(a);
            m2 = getMonomialOrder(b);
            Pair(m1.first + m2.first, m1.second * m2.second);
        };
        Var(a) : Pair(1, 1);
    }
}

sumRatPolynom(l : Maybe<ratPolynom>, r : Maybe<ratPolynom>) -> Maybe<ratPolynom> {
    if (isSome(l) && isSome(r)) {
        newL = either(l, ratPolynom(Int(0),Int(0)));
        newR = either(r, ratPolynom(Int(0),Int(0)));

        if (newL.numerator == Int(0)) r
        else if (newR.numerator == Int(0)) l
        else simplificationRat(Some( ratPolynom(
                        simplification( Sum(
                            simplification( Mul(newL.numerator, newR.denominator) ), 
                            simplification( Mul(newR.numerator, newL.denominator) )) ), 
                        simplification( Mul(newL.denominator, newR.denominator) ))));
    } else {
        None();
    }
}

subRatPolynom(l : Maybe<ratPolynom>, r : Maybe<ratPolynom>) -> Maybe<ratPolynom> {
    if (isSome(l) && isSome(r)) {
        newL = either(l, ratPolynom(Int(0),Int(0)));
        newR = either(r, ratPolynom(Int(0),Int(0)));

        if (newL.numerator == Int(0)) mulRatPolynom(Some(ratPolynom(Int(-1), Int(1))), r)
        else if (newR.numerator == Int(0)) l
        else simplificationRat(Some( ratPolynom(
                        simplification( Sub(
                            simplification( Mul(newL.numerator, newR.denominator) ), 
                            simplification( Mul(newR.numerator, newL.denominator) )) ), 
                        simplification( Mul(newL.denominator, newR.denominator) ))));
    } else {
        None();
    }
}

mulRatPolynom(l : Maybe<ratPolynom>, r : Maybe<ratPolynom>) -> Maybe<ratPolynom> {
    if (isSome(l) && isSome(r)) {
        newL = either(l, ratPolynom(Int(0),Int(0)));
        newR = either(r, ratPolynom(Int(0),Int(0)));

        if (newL.numerator == Int(0) || newR.numerator == Int(0))
            Some(ratPolynom(Int(0), Int(1)))
        else
            simplificationRat(Some( ratPolynom(
                        simplification( Mul(newL.numerator, newR.numerator) ), 
                        simplification( Mul(newL.denominator, newR.denominator) ))));
    } else {
        None();
    }
}

divRatPolynom(l : Maybe<ratPolynom>, r : Maybe<ratPolynom>) -> Maybe<ratPolynom> {
    if (isSome(l) && isSome(r)) {
        newL = either(l, ratPolynom(Int(0),Int(0)));
        newR = either(r, ratPolynom(Int(0),Int(0)));

        if (newL.numerator == Int(0))
            Some(ratPolynom(Int(0), Int(1)))
        else
            simplificationRat(Some( ratPolynom(
                        simplification( Mul(newL.numerator, newR.denominator) ), 
                        simplification( Mul(newL.denominator, newR.numerator) ))));
    } else {
        None();
    }
}

calculatePolynomRat(v : Expr, params : Tree<string, ratNum>) -> Maybe<ratPolynom> {
    switch (v) {
        Sum(a, b) : 
            sumRatPolynom(
                calculatePolynomRat(a, params), 
                calculatePolynomRat(b, params)
            );
        Mul(a, b) : 
            mulRatPolynom(
                calculatePolynomRat(a, params), 
                calculatePolynomRat(b, params)
            );
        Div(a, b) : 
            divRatPolynom(
                calculatePolynomRat(a, params), 
                calculatePolynomRat(b, params)
            );
        Sub(a, b) : 
            subRatPolynom(
                calculatePolynomRat(a, params), 
                calculatePolynomRat(b, params)
            );
        Neg(a) : 
            mulRatPolynom(
                Some(ratPolynom(Int(-1), Int(1))), 
                calculatePolynomRat(a, params)
            );
        Int(a) : 
            Some(ratPolynom(Int(a), Int(1)));
        Var(a) : 
            switch(lookupTree(params, a)) {
                Some(p) : Some(ratPolynom(Int(p.numerator), Int(p.denominator)));
                None()  : Some(ratPolynom(Var(a), Int(1)));
            }
    }
}

ratPolynom2s(rat : Maybe<ratPolynom>) -> string {
    if (isSome(rat)) {
        newRat = either(rat, ratPolynom(Int(0),Int(0)));
        if (newRat.denominator == Int(0)) "Division by zero..."
        else if (newRat.denominator == Int(1)) expr2s(newRat.numerator)
        else expr2s(newRat.numerator) + "/" + expr2s(newRat.denominator);
    } else {
        "Calculate error...";
    }
}

/*
Реализуйте функцию упрощения рациональной функции по заданному набору тождеств.
*/