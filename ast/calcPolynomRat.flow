import calcDiff;

/*
Реализуйте функцию преобразования алгебраического выражения в рациональную функцию (отношение двух многочленов).
*/

export {
    ratPolynom : (numerator : Expr, denominator : Expr);

    sumRatPolynom(l : Maybe<ratPolynom>, r : Maybe<ratPolynom>)  -> Maybe<ratPolynom>;
    subRatPolynom(l : Maybe<ratPolynom>, r : Maybe<ratPolynom>)  -> Maybe<ratPolynom>;
    mulRatPolynom(l : Maybe<ratPolynom>, r : Maybe<ratPolynom>)  -> Maybe<ratPolynom>;
    divRatPolynom(l : Maybe<ratPolynom>, r : Maybe<ratPolynom>)  -> Maybe<ratPolynom>;
    ratPolynom2s(rat : Maybe<ratPolynom>)                        -> string;
    calculatePolynomRat(v : Expr, params : Tree<string, ratNum>) -> Maybe<ratPolynom>;
    simplificationRat(rat : Maybe<ratPolynom>)                   -> Maybe<ratPolynom>;
}

simplificationRat(rat : Maybe<ratPolynom>) -> Maybe<ratPolynom> {
    switch (rat) {
        Some(v) : {
            if (v.numerator.structname == "Int" && v.denominator.structname == "Int") {
                tInt  = cast(v.numerator : Expr -> Int);
                tInt2 = cast(v.denominator : Expr -> Int);
                switch(divRatNum(Some(ratNum(tInt.val, 1)), Some(ratNum(tInt2.val, 1)))) {
                    Some(v2) : Some(ratPolynom(Int(v2.numerator), Int(v2.denominator)));
                    None() : None();
                }
            } else {
                rat;
            }
        }
        None() : None();
    }
}

sumRatPolynom(l : Maybe<ratPolynom>, r : Maybe<ratPolynom>) -> Maybe<ratPolynom> {
    if (isSome(l) && isSome(r)) {
        newL = either(l, ratPolynom(Int(0),Int(0)));
        newR = either(r, ratPolynom(Int(0),Int(0)));

        if (newL.numerator == Int(0)) r
        else if (newR.numerator == Int(0)) l
        else simplificationRat(Some( ratPolynom(
                        simplification( Sum(
                            simplification( Mul(newL.numerator, newR.denominator) ), 
                            simplification( Mul(newR.numerator, newL.denominator) )) ), 
                        simplification( Mul(newL.denominator, newR.denominator) ))));
    } else {
        None();
    }
}

subRatPolynom(l : Maybe<ratPolynom>, r : Maybe<ratPolynom>) -> Maybe<ratPolynom> {
    if (isSome(l) && isSome(r)) {
        newL = either(l, ratPolynom(Int(0),Int(0)));
        newR = either(r, ratPolynom(Int(0),Int(0)));

        if (newL.numerator == Int(0)) mulRatPolynom(Some(ratPolynom(Int(-1), Int(1))), r)
        else if (newR.numerator == Int(0)) l
        else simplificationRat(Some( ratPolynom(
                        simplification( Sub(
                            simplification( Mul(newL.numerator, newR.denominator) ), 
                            simplification( Mul(newR.numerator, newL.denominator) )) ), 
                        simplification( Mul(newL.denominator, newR.denominator) ))));
    } else {
        None();
    }
}

mulRatPolynom(l : Maybe<ratPolynom>, r : Maybe<ratPolynom>) -> Maybe<ratPolynom> {
    if (isSome(l) && isSome(r)) {
        newL = either(l, ratPolynom(Int(0),Int(0)));
        newR = either(r, ratPolynom(Int(0),Int(0)));

        if (newL.numerator == Int(0) || newR.numerator == Int(0))
            Some(ratPolynom(Int(0), Int(1)))
        else
            simplificationRat(Some( ratPolynom(
                        simplification( Mul(newL.numerator, newR.numerator) ), 
                        simplification( Mul(newL.denominator, newR.denominator) ))));
    } else {
        None();
    }
}

divRatPolynom(l : Maybe<ratPolynom>, r : Maybe<ratPolynom>) -> Maybe<ratPolynom> {
    if (isSome(l) && isSome(r)) {
        newL = either(l, ratPolynom(Int(0),Int(0)));
        newR = either(r, ratPolynom(Int(0),Int(0)));

        if (newL.numerator == Int(0))
            Some(ratPolynom(Int(0), Int(1)))
        else
            simplificationRat(Some( ratPolynom(
                        simplification( Mul(newL.numerator, newR.denominator) ), 
                        simplification( Mul(newL.denominator, newR.numerator) ))));
    } else {
        None();
    }
}

calculatePolynomRat(v : Expr, params : Tree<string, ratNum>) -> Maybe<ratPolynom> {
    switch (v) {
        Sum(a, b) : 
            sumRatPolynom(
                calculatePolynomRat(a, params), 
                calculatePolynomRat(b, params)
            );
        Mul(a, b) : 
            mulRatPolynom(
                calculatePolynomRat(a, params), 
                calculatePolynomRat(b, params)
            );
        Div(a, b) : 
            divRatPolynom(
                calculatePolynomRat(a, params), 
                calculatePolynomRat(b, params)
            );
        Sub(a, b) : 
            subRatPolynom(
                calculatePolynomRat(a, params), 
                calculatePolynomRat(b, params)
            );
        Neg(a) : 
            mulRatPolynom(
                Some(ratPolynom(Int(-1), Int(1))), 
                calculatePolynomRat(a, params)
            );
        Int(a) : 
            Some(ratPolynom(Int(a), Int(1)));
        Var(a) : 
            switch(lookupTree(params, a)) {
                Some(p) : Some(ratPolynom(Int(p.numerator), Int(p.denominator)));
                None()  : Some(ratPolynom(Var(a), Int(1)));
            }
    }
}

ratPolynom2s(rat : Maybe<ratPolynom>) -> string {
    if (isSome(rat)) {
        newRat = either(rat, ratPolynom(Int(0),Int(0)));
        if (newRat.denominator == Int(0)) "Division by zero..."
        else if (newRat.denominator == Int(1)) expr2s(newRat.numerator)
        else expr2s(newRat.numerator) + "/" + expr2s(newRat.denominator);
    } else {
        "Calculate error...";
    }
}

/*
Реализуйте функцию упрощения рациональной функции по заданному набору тождеств.
*/