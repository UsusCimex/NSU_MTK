import calcDiff;

/*
Реализуйте функцию преобразования алгебраического выражения в рациональную функцию (отношение двух многочленов).
*/

export {
    ratPolynom : (numerator : Expr, denominator : Expr);

    sumRatPolynom(l : Maybe<ratPolynom>, r : Maybe<ratPolynom>)  -> Maybe<ratPolynom>;
    subRatPolynom(l : Maybe<ratPolynom>, r : Maybe<ratPolynom>)  -> Maybe<ratPolynom>;
    mulRatPolynom(l : Maybe<ratPolynom>, r : Maybe<ratPolynom>)  -> Maybe<ratPolynom>;
    divRatPolynom(l : Maybe<ratPolynom>, r : Maybe<ratPolynom>)  -> Maybe<ratPolynom>;
    ratPolynom2s(rat : Maybe<ratPolynom>)                        -> string;
    calculatePolynomRat(v : Expr, params : Tree<string, ratNum>) -> Maybe<ratPolynom>;
    simplificationRat(rat : Maybe<ratPolynom>)                   -> Maybe<ratPolynom>;
}

simplificationRat(rat : Maybe<ratPolynom>) -> Maybe<ratPolynom> {
    switch (rat) {
        Some(v) : {
            if (v.numerator.structname == "Int" && v.denominator.structname == "Int") {
                tInt  = cast(v.numerator : Expr -> Int);
                tInt2 = cast(v.denominator : Expr -> Int);
                switch(divRatNum(Some(ratNum(tInt.val, 1)), Some(ratNum(tInt2.val, 1)))) {
                    Some(v2) : Some(ratPolynom(Int(v2.numerator), Int(v2.denominator)));
                    None() : None();
                }
            } else {
                numerator = v.numerator;
                denominator = v.denominator;
                tr = makeTree();
                trNum = getPolynomTree(numerator, tr);
                trDen = getPolynomTree(denominator, tr);
                // need logic 0_0 xD
                rat;
            }
        }
        None() : None();
    }
}

getPolynomTree(ex : Expr, tree : Tree<int, int>) -> Tree<int, int> {
    switch (ex) {
		Mul(a, b) : {
            mp = getMonomialOrder(ex);
            p = either(mp, Pair(0, 0));
            switch (lookupTree(tree, p.first)) {
                Some(v) : setTree(tree, p.first, p.second + v);
                None() : setTree(tree, p.first, p.second);
            }
        }
		Sum(a, b) : {
            tr = getPolynomTree(a, tree);
            getPolynomTree(b, tr);
        }
        Div(a, b) : tree;
        Sub(a, b) : {
            tr = getPolynomTree(a, tree);
            getPolynomTree(b, tr);
        }
        Neg(a)    : getPolynomTree(a, tree);
        Int(a)    : switch(lookupTree(tree, 0)) {
                        Some(v) : setTree(tree, 0, v + a);
                        None() : setTree(tree, 0, a);
                    }
        Var(a)    : switch(lookupTree(tree, 1)) {
                        Some(v) : setTree(tree, 1, v + 1);
                        None() : setTree(tree, 1, 1);
                    }
	}
}

// Return pair(oder, value)
getMonomialOrder(ex : Expr) -> Maybe<Pair<int, int>> {
    switch (ex) {
        Int(a)    : Some(Pair(0, a));
        Neg(a)    : getMonomialOrder(a);
        Sum(a, b) : None();
        Sub(a, b) : None();
        Div(a, b) : None();
        Mul(a, b) : {
            p = if (a.structname == "Var") getMonomialOrder(b)
                else getMonomialOrder(a);
            
            switch (p) {
                Some(val) : Some(Pair(1 + val.first, val.second));
                None() : None();
            }
        };
        Var(a) : Some(Pair(1, 1));
    }
}

sumRatPolynom(l : Maybe<ratPolynom>, r : Maybe<ratPolynom>) -> Maybe<ratPolynom> {
    if (isSome(l) && isSome(r)) {
        newL = either(l, ratPolynom(Int(0),Int(0)));
        newR = either(r, ratPolynom(Int(0),Int(0)));

        if (newL.numerator == Int(0)) r
        else if (newR.numerator == Int(0)) l
        else simplificationRat(Some( ratPolynom(
                        simplification( Sum(
                            simplification( Mul(newL.numerator, newR.denominator) ), 
                            simplification( Mul(newR.numerator, newL.denominator) )) ), 
                        simplification( Mul(newL.denominator, newR.denominator) ))));
    } else {
        None();
    }
}

subRatPolynom(l : Maybe<ratPolynom>, r : Maybe<ratPolynom>) -> Maybe<ratPolynom> {
    if (isSome(l) && isSome(r)) {
        newL = either(l, ratPolynom(Int(0),Int(0)));
        newR = either(r, ratPolynom(Int(0),Int(0)));

        if (newL.numerator == Int(0)) mulRatPolynom(Some(ratPolynom(Int(-1), Int(1))), r)
        else if (newR.numerator == Int(0)) l
        else simplificationRat(Some( ratPolynom(
                        simplification( Sub(
                            simplification( Mul(newL.numerator, newR.denominator) ), 
                            simplification( Mul(newR.numerator, newL.denominator) )) ), 
                        simplification( Mul(newL.denominator, newR.denominator) ))));
    } else {
        None();
    }
}

mulRatPolynom(l : Maybe<ratPolynom>, r : Maybe<ratPolynom>) -> Maybe<ratPolynom> {
    if (isSome(l) && isSome(r)) {
        newL = either(l, ratPolynom(Int(0),Int(0)));
        newR = either(r, ratPolynom(Int(0),Int(0)));

        if (newL.numerator == Int(0) || newR.numerator == Int(0))
            Some(ratPolynom(Int(0), Int(1)))
        else
            simplificationRat(Some( ratPolynom(
                        simplification( Mul(newL.numerator, newR.numerator) ), 
                        simplification( Mul(newL.denominator, newR.denominator) ))));
    } else {
        None();
    }
}

divRatPolynom(l : Maybe<ratPolynom>, r : Maybe<ratPolynom>) -> Maybe<ratPolynom> {
    if (isSome(l) && isSome(r)) {
        newL = either(l, ratPolynom(Int(0),Int(0)));
        newR = either(r, ratPolynom(Int(0),Int(0)));

        if (newL.numerator == Int(0))
            Some(ratPolynom(Int(0), Int(1)))
        else
            simplificationRat(Some( ratPolynom(
                        simplification( Mul(newL.numerator, newR.denominator) ), 
                        simplification( Mul(newL.denominator, newR.numerator) ))));
    } else {
        None();
    }
}

calculatePolynomRat(v : Expr, params : Tree<string, ratNum>) -> Maybe<ratPolynom> {
    switch (v) {
        Sum(a, b) : 
            sumRatPolynom(
                calculatePolynomRat(a, params), 
                calculatePolynomRat(b, params)
            );
        Mul(a, b) : 
            mulRatPolynom(
                calculatePolynomRat(a, params), 
                calculatePolynomRat(b, params)
            );
        Div(a, b) : 
            divRatPolynom(
                calculatePolynomRat(a, params), 
                calculatePolynomRat(b, params)
            );
        Sub(a, b) : 
            subRatPolynom(
                calculatePolynomRat(a, params), 
                calculatePolynomRat(b, params)
            );
        Neg(a) : 
            mulRatPolynom(
                Some(ratPolynom(Int(-1), Int(1))), 
                calculatePolynomRat(a, params)
            );
        Int(a) : 
            Some(ratPolynom(Int(a), Int(1)));
        Var(a) : 
            switch(lookupTree(params, a)) {
                Some(p) : Some(ratPolynom(Int(p.numerator), Int(p.denominator)));
                None()  : Some(ratPolynom(Var(a), Int(1)));
            }
    }
}

ratPolynom2s(rat : Maybe<ratPolynom>) -> string {
    if (isSome(rat)) {
        newRat = either(rat, ratPolynom(Int(0),Int(0)));
        if (newRat.denominator == Int(0)) "Division by zero..."
        else if (newRat.denominator == Int(1)) expr2s(newRat.numerator)
        else expr2s(newRat.numerator) + "/" + expr2s(newRat.denominator);
    } else {
        "Calculate error...";
    }
}

/*
Реализуйте функцию упрощения рациональной функции по заданному набору тождеств.
*/